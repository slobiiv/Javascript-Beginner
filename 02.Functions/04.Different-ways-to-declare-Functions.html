<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Diferent ways to declare a Function</title>
</head>

<body>

  <script>
    // Javascript functions are first class citizens. - That means that javascript functions are values in themselves.

    // Declaring functions in multiple ways:

    /* 1# Regular function
    function doctorize(firstName) {
       return `Dr. ${firstName}`;
     } */


    /* 2# Anonymous function - a function without a name
    function (firstName) {
       return `Dr. ${firstName}`;
    */


    /* 3# Function expression - a function where you store a function as a value in variable (this function is technicaly anonymous) , and the browser will use the name of the variable as a name of the function:
      const doctorize = function(firstName) {
        return `Dr. ${firstName}`;
      }
    */


    /* #4 Arrow function is an Anonymous function- concise and short syntax, don't have their own scope in refer to 'this' keyword */
    function inchToCM(inches) {
      const cm = inches * 2.54;
      return cm;
    }
    // Arrow function example(exact same example as above):
    const inchToCM = (inches) => inches * 2.54; // implicit return
    const inchToCM = inches => inches * 2.54; // If you have only one parameter you don't need parentheses at all ()

    // Another example of an arrow function
    function add(a, b = 3) {
      const total = a + b;
      return total;
    }
    const add = (a, b = 3) => a + b;

    // Another example of an arrow function - RETURNING AND OBJECT
    function makeABaby(first, last) {
      const baby = {
        name: `${first} ${last}`,
        age: 0
      }
      return baby;
    }
    // This look of the arrow function is perfectly  correct ...
    const makeABaby = (first, last) => {
      const baby = {
        name: `${first} ${last}`,
        age: 0
      }
      return baby; // always return 
    }
    // ... but if you want to make it even shorter continue:
    // const makeABaby = (first, last) => { return { name: `${first} ${last}`, age: 0 } }
    const makeABaby = (first, last) => ({ name: `${first} ${last}`, age: 0 }); // not the most readable
    // This is not always the best way to declare a function.


    // #5 IIFE - Immediately Invoked Function Expression (wrapping function inside parantheses. )
    // ** Parantheses always run first in JavaScript**
    // 1.step - Wrap the function with parantheses
    // 2.step - Add another pair of paratheses  invoking(calling) a function
    (function () {
      console.log('Running and IIFE');
      return 'You are cool';
    })();
    // What if I need parameters?
    (function (age) {
      console.log('Running and IIFE');
      return `You are cool and age ${age}`;
    })(31);
    /* *What is the benefit?
     Good for scoping. It will sort of provide us our own little sheltered space where variables can't leak inside
    */


    // #6 METHODS - Is simply a function that lives inside of an Object
    const slobodan = {
      name: 'Slobodan',
      // Here comes METHOD:
      sayHi: function () {
        return 'Hi Slobodan';
      },
      // SHORTHAND METHOD: get rid of colon, and it will make property called 'yellHi' set to a function called 'yellHi()'
      yellHi() {
        console.log('HII SLOBODAAN!!!');
      },
      // SHORTHAND METHOD: ARROW FUNCTION
      whisperHi: () => {
        console.log('hii sssslobooo, im a mousssse.');
      }
    }


    // CALLBACK FUNCTIONS - is a regular function but we use that name for something that will happen when something is done
    // *** Explain to a kid : WHEN SOMEONE CLICKS SOMETHING, RUN THIS - OR WHEN THIS AMOUNT OF TIME HAS PASSED, RUN THIS

    // 1. click callback
    // const button = document.querySelector('.clickMe');
    button.addEventListener('click', slobodan.yellHi);
    /* We don't call the function, we gave just the acces to that function.
      So, when someone click that button that triggers the function, it will call the function.
      That is what is referred to as a callback function.
    */

    //2. callback functions can be declared outside of the handler (common usage)
    function handleClick() {
      console.log('Great Clicking!');
    }
    button.addEventListener('click', handleClick); // when someone click the button, here is the function you should run browser!

    //3. callback function declared inside the handler(anonymous function declaration)
    button.addEventListener('click', function () {
      console.log('Nice Job Wes!');
    });

    // Timer callback function - first takes the function which should run, and second it takes the parameter which defines after what time to run
    setTimeout(handleClick(), 2000);

    // anonymous inside timer callback
    setTimeout(function () {
      console.log('Done! Time to eat!');
    }, 2000);

    // Arrow function timer callback
    setTimeout(() => {
      console.log('Done! Time to eat!');
    }, 2000);


  </script>
  <!-- <button class="clickMe">click me</button> -->
</body>

</html>